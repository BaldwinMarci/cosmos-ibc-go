// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ibc/applications/fee/v1/tx.proto

package types

import (
	context "context"
	fmt "fmt"
	types "github.com/cosmos/ibc-go/modules/core/04-channel/types"
	_ "github.com/gogo/protobuf/gogoproto"
	grpc1 "github.com/gogo/protobuf/grpc"
	proto "github.com/gogo/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// MsgRegisterCounterpartyAddress is the request type for registering the counter party address
type MsgRegisterCounterpartyAddress struct {
	Address             string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	CounterpartyAddress string `protobuf:"bytes,2,opt,name=counterparty_address,json=counterpartyAddress,proto3" json:"counterparty_address,omitempty" yaml:"counterparty_address"`
}

func (m *MsgRegisterCounterpartyAddress) Reset()         { *m = MsgRegisterCounterpartyAddress{} }
func (m *MsgRegisterCounterpartyAddress) String() string { return proto.CompactTextString(m) }
func (*MsgRegisterCounterpartyAddress) ProtoMessage()    {}
func (*MsgRegisterCounterpartyAddress) Descriptor() ([]byte, []int) {
	return fileDescriptor_05c93128649f1b96, []int{0}
}
func (m *MsgRegisterCounterpartyAddress) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRegisterCounterpartyAddress) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRegisterCounterpartyAddress.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRegisterCounterpartyAddress) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRegisterCounterpartyAddress.Merge(m, src)
}
func (m *MsgRegisterCounterpartyAddress) XXX_Size() int {
	return m.Size()
}
func (m *MsgRegisterCounterpartyAddress) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRegisterCounterpartyAddress.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRegisterCounterpartyAddress proto.InternalMessageInfo

// MsgRegisterCounterpartyAddressResponse defines the Msg/RegisterCounterypartyAddress response type
type MsgRegisterCounterpartyAddressResponse struct {
}

func (m *MsgRegisterCounterpartyAddressResponse) Reset() {
	*m = MsgRegisterCounterpartyAddressResponse{}
}
func (m *MsgRegisterCounterpartyAddressResponse) String() string { return proto.CompactTextString(m) }
func (*MsgRegisterCounterpartyAddressResponse) ProtoMessage()    {}
func (*MsgRegisterCounterpartyAddressResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_05c93128649f1b96, []int{1}
}
func (m *MsgRegisterCounterpartyAddressResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRegisterCounterpartyAddressResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRegisterCounterpartyAddressResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRegisterCounterpartyAddressResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRegisterCounterpartyAddressResponse.Merge(m, src)
}
func (m *MsgRegisterCounterpartyAddressResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgRegisterCounterpartyAddressResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRegisterCounterpartyAddressResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRegisterCounterpartyAddressResponse proto.InternalMessageInfo

// MsgEscrowPacketFee defines the request type EscrowPacketFee RPC
type MsgPayPacketFee struct {
	Fee *Fee `protobuf:"bytes,1,opt,name=fee,proto3" json:"fee,omitempty"`
	// source channel port identifier
	SourcePortId string `protobuf:"bytes,2,opt,name=source_port_id,json=sourcePortId,proto3" json:"source_port_id,omitempty" yaml:"source_port_id"`
	// source channel unique identifier
	SourceChannelId string `protobuf:"bytes,3,opt,name=source_channel_id,json=sourceChannelId,proto3" json:"source_channel_id,omitempty" yaml:"source_channel_id"`
	// account address to refund fee if necessary
	RefundAccount string   `protobuf:"bytes,4,opt,name=refund_account,json=refundAccount,proto3" json:"refund_account,omitempty" yaml:"source_port_id"`
	Relayers      []string `protobuf:"bytes,5,rep,name=relayers,proto3" json:"relayers,omitempty"`
}

func (m *MsgPayPacketFee) Reset()         { *m = MsgPayPacketFee{} }
func (m *MsgPayPacketFee) String() string { return proto.CompactTextString(m) }
func (*MsgPayPacketFee) ProtoMessage()    {}
func (*MsgPayPacketFee) Descriptor() ([]byte, []int) {
	return fileDescriptor_05c93128649f1b96, []int{2}
}
func (m *MsgPayPacketFee) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgPayPacketFee) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgPayPacketFee.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgPayPacketFee) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgPayPacketFee.Merge(m, src)
}
func (m *MsgPayPacketFee) XXX_Size() int {
	return m.Size()
}
func (m *MsgPayPacketFee) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgPayPacketFee.DiscardUnknown(m)
}

var xxx_messageInfo_MsgPayPacketFee proto.InternalMessageInfo

// MsgEscrowPacketFeeResponse defines the response type for Msg/EscrowPacketFee
type MsgPayPacketFeeResponse struct {
}

func (m *MsgPayPacketFeeResponse) Reset()         { *m = MsgPayPacketFeeResponse{} }
func (m *MsgPayPacketFeeResponse) String() string { return proto.CompactTextString(m) }
func (*MsgPayPacketFeeResponse) ProtoMessage()    {}
func (*MsgPayPacketFeeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_05c93128649f1b96, []int{3}
}
func (m *MsgPayPacketFeeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgPayPacketFeeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgPayPacketFeeResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgPayPacketFeeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgPayPacketFeeResponse.Merge(m, src)
}
func (m *MsgPayPacketFeeResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgPayPacketFeeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgPayPacketFeeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgPayPacketFeeResponse proto.InternalMessageInfo

// MsgEscrowPacketFeeAsync defines the request type EscrowPacketFeeAsync RPC
type MsgPayPacketFeeAsync struct {
	// source channel port identifier
	Fee *Fee `protobuf:"bytes,1,opt,name=fee,proto3" json:"fee,omitempty"`
	// source channel unique identifier
	PacketId *types.PacketId `protobuf:"bytes,2,opt,name=packet_id,json=packetId,proto3" json:"packet_id,omitempty" yaml:"packet_id"`
	// account address to refund fee if necessary
	RefundAccount string   `protobuf:"bytes,3,opt,name=refund_account,json=refundAccount,proto3" json:"refund_account,omitempty" yaml:"source_port_id"`
	Relayers      []string `protobuf:"bytes,4,rep,name=relayers,proto3" json:"relayers,omitempty"`
}

func (m *MsgPayPacketFeeAsync) Reset()         { *m = MsgPayPacketFeeAsync{} }
func (m *MsgPayPacketFeeAsync) String() string { return proto.CompactTextString(m) }
func (*MsgPayPacketFeeAsync) ProtoMessage()    {}
func (*MsgPayPacketFeeAsync) Descriptor() ([]byte, []int) {
	return fileDescriptor_05c93128649f1b96, []int{4}
}
func (m *MsgPayPacketFeeAsync) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgPayPacketFeeAsync) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgPayPacketFeeAsync.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgPayPacketFeeAsync) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgPayPacketFeeAsync.Merge(m, src)
}
func (m *MsgPayPacketFeeAsync) XXX_Size() int {
	return m.Size()
}
func (m *MsgPayPacketFeeAsync) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgPayPacketFeeAsync.DiscardUnknown(m)
}

var xxx_messageInfo_MsgPayPacketFeeAsync proto.InternalMessageInfo

// MsgEscrowPacketFeeAsyncResponse defines the response type for Msg/EscrowPacketFeeAsync
type MsgPayPacketFeeAsyncResponse struct {
}

func (m *MsgPayPacketFeeAsyncResponse) Reset()         { *m = MsgPayPacketFeeAsyncResponse{} }
func (m *MsgPayPacketFeeAsyncResponse) String() string { return proto.CompactTextString(m) }
func (*MsgPayPacketFeeAsyncResponse) ProtoMessage()    {}
func (*MsgPayPacketFeeAsyncResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_05c93128649f1b96, []int{5}
}
func (m *MsgPayPacketFeeAsyncResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgPayPacketFeeAsyncResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgPayPacketFeeAsyncResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgPayPacketFeeAsyncResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgPayPacketFeeAsyncResponse.Merge(m, src)
}
func (m *MsgPayPacketFeeAsyncResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgPayPacketFeeAsyncResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgPayPacketFeeAsyncResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgPayPacketFeeAsyncResponse proto.InternalMessageInfo

func init() {
	proto.RegisterType((*MsgRegisterCounterpartyAddress)(nil), "ibc.applications.fee.v1.MsgRegisterCounterpartyAddress")
	proto.RegisterType((*MsgRegisterCounterpartyAddressResponse)(nil), "ibc.applications.fee.v1.MsgRegisterCounterpartyAddressResponse")
	proto.RegisterType((*MsgPayPacketFee)(nil), "ibc.applications.fee.v1.MsgPayPacketFee")
	proto.RegisterType((*MsgPayPacketFeeResponse)(nil), "ibc.applications.fee.v1.MsgPayPacketFeeResponse")
	proto.RegisterType((*MsgPayPacketFeeAsync)(nil), "ibc.applications.fee.v1.MsgPayPacketFeeAsync")
	proto.RegisterType((*MsgPayPacketFeeAsyncResponse)(nil), "ibc.applications.fee.v1.MsgPayPacketFeeAsyncResponse")
}

func init() { proto.RegisterFile("ibc/applications/fee/v1/tx.proto", fileDescriptor_05c93128649f1b96) }

var fileDescriptor_05c93128649f1b96 = []byte{
	// 592 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x94, 0x31, 0x6f, 0xd3, 0x40,
	0x14, 0xc7, 0xe3, 0xba, 0x40, 0x72, 0x2d, 0x2d, 0x35, 0x41, 0x4d, 0xdd, 0x60, 0x07, 0x0f, 0x28,
	0x4b, 0x6c, 0x12, 0x84, 0x10, 0x5d, 0x4a, 0x52, 0xa9, 0x22, 0x12, 0x91, 0x22, 0x8f, 0x2c, 0x91,
	0x73, 0x7e, 0x71, 0x0d, 0x89, 0xcf, 0xba, 0x73, 0x22, 0xbc, 0x31, 0x21, 0x46, 0x36, 0x18, 0xfb,
	0x21, 0xf8, 0x10, 0x8c, 0x1d, 0x99, 0x22, 0x94, 0x2c, 0xcc, 0xf9, 0x04, 0xc8, 0xbe, 0x38, 0x24,
	0x6d, 0x12, 0x5a, 0xd8, 0xee, 0xee, 0xfd, 0xde, 0xff, 0xbd, 0xfb, 0xeb, 0xdd, 0xa1, 0x82, 0xdb,
	0xc6, 0x86, 0xe5, 0xfb, 0x5d, 0x17, 0x5b, 0x81, 0x4b, 0x3c, 0x66, 0x74, 0x00, 0x8c, 0x41, 0xd9,
	0x08, 0xde, 0xeb, 0x3e, 0x25, 0x01, 0x91, 0xf6, 0xdd, 0x36, 0xd6, 0xe7, 0x09, 0xbd, 0x03, 0xa0,
	0x0f, 0xca, 0x72, 0xd6, 0x21, 0x0e, 0x89, 0x19, 0x23, 0x5a, 0x71, 0x5c, 0x7e, 0xb4, 0x4a, 0x30,
	0xca, 0x9a, 0x43, 0x30, 0xa1, 0x60, 0xe0, 0x33, 0xcb, 0xf3, 0xa0, 0x1b, 0x85, 0xa7, 0x4b, 0x8e,
	0x68, 0x5f, 0x05, 0xa4, 0x34, 0x98, 0x63, 0x82, 0xe3, 0xb2, 0x00, 0xe8, 0x09, 0xe9, 0x7b, 0x01,
	0x50, 0xdf, 0xa2, 0x41, 0x58, 0xb5, 0x6d, 0x0a, 0x8c, 0x49, 0x39, 0x74, 0xc7, 0xe2, 0xcb, 0x9c,
	0x50, 0x10, 0x8a, 0x19, 0x33, 0xd9, 0x4a, 0x26, 0xca, 0xe2, 0xb9, 0x84, 0x56, 0x82, 0x6d, 0x44,
	0x58, 0x4d, 0x9d, 0x0c, 0xd5, 0xc3, 0xd0, 0xea, 0x75, 0x8f, 0xb4, 0x65, 0x94, 0x66, 0xde, 0xc7,
	0x57, 0xab, 0x1d, 0xa5, 0x3f, 0x9d, 0xab, 0xa9, 0x5f, 0xe7, 0x6a, 0x4a, 0x2b, 0xa2, 0xc7, 0xeb,
	0x3b, 0x33, 0x81, 0xf9, 0xc4, 0x63, 0xa0, 0x7d, 0xdb, 0x40, 0xbb, 0x0d, 0xe6, 0x34, 0xad, 0xb0,
	0x69, 0xe1, 0x77, 0x10, 0x9c, 0x02, 0x48, 0x3a, 0x12, 0x3b, 0x00, 0x71, 0xc7, 0x5b, 0x95, 0xbc,
	0xbe, 0xc2, 0x5b, 0xfd, 0x14, 0xc0, 0x8c, 0x40, 0xe9, 0x18, 0xed, 0x30, 0xd2, 0xa7, 0x18, 0x5a,
	0x3e, 0xa1, 0x41, 0xcb, 0xb5, 0xa7, 0xb7, 0x38, 0x98, 0x0c, 0xd5, 0x07, 0xfc, 0x16, 0x8b, 0x71,
	0xcd, 0xdc, 0xe6, 0x07, 0x4d, 0x42, 0x83, 0xba, 0x2d, 0xbd, 0x42, 0x7b, 0x53, 0x60, 0xea, 0x70,
	0xa4, 0x21, 0xc6, 0x1a, 0xf9, 0xc9, 0x50, 0xcd, 0x2d, 0x68, 0xfc, 0x41, 0x34, 0x73, 0x97, 0x9f,
	0x9d, 0xf0, 0xa3, 0xba, 0x2d, 0xbd, 0x44, 0x3b, 0x14, 0x3a, 0x7d, 0xcf, 0x6e, 0x59, 0x38, 0xb6,
	0x28, 0xb7, 0xf9, 0xb7, 0x56, 0xee, 0xf2, 0x84, 0x2a, 0xe7, 0x25, 0x19, 0xa5, 0x29, 0x74, 0xad,
	0x10, 0x28, 0xcb, 0xdd, 0x2a, 0x88, 0xc5, 0x8c, 0x39, 0xdb, 0xcf, 0x19, 0x7c, 0x80, 0xf6, 0x2f,
	0xb9, 0x36, 0x73, 0xf4, 0xc3, 0x06, 0xca, 0x5e, 0x8a, 0x55, 0x59, 0xe8, 0xe1, 0x1b, 0xdb, 0xda,
	0x44, 0x19, 0x3f, 0x56, 0x48, 0x1c, 0xdd, 0xaa, 0x3c, 0x8c, 0xb3, 0xa2, 0xb1, 0xd4, 0x93, 0x59,
	0x1c, 0x94, 0x75, 0x5e, 0xa7, 0x6e, 0xd7, 0xb2, 0x93, 0xa1, 0x7a, 0x8f, 0xdf, 0x72, 0x96, 0xa9,
	0x99, 0x69, 0x7f, 0x1a, 0x5f, 0xe2, 0x8e, 0xf8, 0x1f, 0xee, 0x6c, 0xae, 0x74, 0x47, 0x41, 0xf9,
	0x65, 0x0e, 0x24, 0x16, 0x55, 0x3e, 0x8a, 0x48, 0x6c, 0x30, 0x47, 0xfa, 0x22, 0xa0, 0xc3, 0x75,
	0xcf, 0xe7, 0xf9, 0x4a, 0x93, 0xd6, 0x4f, 0xb7, 0x7c, 0xfc, 0x8f, 0x89, 0x49, 0x87, 0xd2, 0x5b,
	0xb4, 0xbd, 0xf0, 0x24, 0x8a, 0xeb, 0x04, 0xe7, 0x49, 0xf9, 0xc9, 0x75, 0xc9, 0x59, 0xad, 0x10,
	0xed, 0x5d, 0x1d, 0x96, 0xd2, 0x75, 0x65, 0x62, 0x5c, 0x7e, 0x76, 0x23, 0x3c, 0x29, 0x5d, 0x7b,
	0xfd, 0x7d, 0xa4, 0x08, 0x17, 0x23, 0x45, 0xf8, 0x39, 0x52, 0x84, 0xcf, 0x63, 0x25, 0x75, 0x31,
	0x56, 0x52, 0x3f, 0xc6, 0x4a, 0xea, 0x4d, 0xc5, 0x71, 0x83, 0xb3, 0x7e, 0x5b, 0xc7, 0xa4, 0x67,
	0x60, 0xc2, 0x7a, 0x84, 0x19, 0x6e, 0x1b, 0x97, 0x1c, 0x62, 0xf4, 0x88, 0xdd, 0xef, 0x02, 0x8b,
	0xfe, 0x4f, 0x66, 0x54, 0x5e, 0x94, 0xa2, 0xaf, 0x33, 0x08, 0x7d, 0x60, 0xed, 0xdb, 0xf1, 0xbf,
	0xf8, 0xf4, 0x77, 0x00, 0x00, 0x00, 0xff, 0xff, 0x71, 0x80, 0x01, 0xb4, 0xb0, 0x05, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// MsgClient is the client API for Msg service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type MsgClient interface {
	// RegisterCounterpartyAddress defines a rpc handler method for MsgRegisterCounterpartyAddress
	// RegisterCounterpartyAddress is called by the relayer on each channelEnd and allows them to specify their
	// counterparty address before relaying. This ensures they will be properly compensated for forward relaying since
	// destination chain must send back relayer's source address (counterparty address) in acknowledgement. This function
	// may be called more than once by a relayer, in which case, latest counterparty address is always used.
	RegisterCounterpartyAddress(ctx context.Context, in *MsgRegisterCounterpartyAddress, opts ...grpc.CallOption) (*MsgRegisterCounterpartyAddressResponse, error)
	// PayPacketFee defines a rpc handler method for MsgPayPacketFee
	// PayPacketFee is an open callback that may be called by any module/user that wishes to escrow funds in order to
	// incentivize the relaying of the given packet.
	PayPacketFee(ctx context.Context, in *MsgPayPacketFee, opts ...grpc.CallOption) (*MsgPayPacketFeeResponse, error)
	// PayPacketFee defines a rpc handler method for MsgPayPacketFee
	// PayPacketFee is an open callback that may be called by any module/user that wishes to escrow funds in order to
	// incentivize the relaying of the given packet.
	PayPacketFeeAsync(ctx context.Context, in *MsgPayPacketFeeAsync, opts ...grpc.CallOption) (*MsgPayPacketFeeAsyncResponse, error)
}

type msgClient struct {
	cc grpc1.ClientConn
}

func NewMsgClient(cc grpc1.ClientConn) MsgClient {
	return &msgClient{cc}
}

func (c *msgClient) RegisterCounterpartyAddress(ctx context.Context, in *MsgRegisterCounterpartyAddress, opts ...grpc.CallOption) (*MsgRegisterCounterpartyAddressResponse, error) {
	out := new(MsgRegisterCounterpartyAddressResponse)
	err := c.cc.Invoke(ctx, "/ibc.applications.fee.v1.Msg/RegisterCounterpartyAddress", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) PayPacketFee(ctx context.Context, in *MsgPayPacketFee, opts ...grpc.CallOption) (*MsgPayPacketFeeResponse, error) {
	out := new(MsgPayPacketFeeResponse)
	err := c.cc.Invoke(ctx, "/ibc.applications.fee.v1.Msg/PayPacketFee", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) PayPacketFeeAsync(ctx context.Context, in *MsgPayPacketFeeAsync, opts ...grpc.CallOption) (*MsgPayPacketFeeAsyncResponse, error) {
	out := new(MsgPayPacketFeeAsyncResponse)
	err := c.cc.Invoke(ctx, "/ibc.applications.fee.v1.Msg/PayPacketFeeAsync", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MsgServer is the server API for Msg service.
type MsgServer interface {
	// RegisterCounterpartyAddress defines a rpc handler method for MsgRegisterCounterpartyAddress
	// RegisterCounterpartyAddress is called by the relayer on each channelEnd and allows them to specify their
	// counterparty address before relaying. This ensures they will be properly compensated for forward relaying since
	// destination chain must send back relayer's source address (counterparty address) in acknowledgement. This function
	// may be called more than once by a relayer, in which case, latest counterparty address is always used.
	RegisterCounterpartyAddress(context.Context, *MsgRegisterCounterpartyAddress) (*MsgRegisterCounterpartyAddressResponse, error)
	// PayPacketFee defines a rpc handler method for MsgPayPacketFee
	// PayPacketFee is an open callback that may be called by any module/user that wishes to escrow funds in order to
	// incentivize the relaying of the given packet.
	PayPacketFee(context.Context, *MsgPayPacketFee) (*MsgPayPacketFeeResponse, error)
	// PayPacketFee defines a rpc handler method for MsgPayPacketFee
	// PayPacketFee is an open callback that may be called by any module/user that wishes to escrow funds in order to
	// incentivize the relaying of the given packet.
	PayPacketFeeAsync(context.Context, *MsgPayPacketFeeAsync) (*MsgPayPacketFeeAsyncResponse, error)
}

// UnimplementedMsgServer can be embedded to have forward compatible implementations.
type UnimplementedMsgServer struct {
}

func (*UnimplementedMsgServer) RegisterCounterpartyAddress(ctx context.Context, req *MsgRegisterCounterpartyAddress) (*MsgRegisterCounterpartyAddressResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterCounterpartyAddress not implemented")
}
func (*UnimplementedMsgServer) PayPacketFee(ctx context.Context, req *MsgPayPacketFee) (*MsgPayPacketFeeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PayPacketFee not implemented")
}
func (*UnimplementedMsgServer) PayPacketFeeAsync(ctx context.Context, req *MsgPayPacketFeeAsync) (*MsgPayPacketFeeAsyncResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PayPacketFeeAsync not implemented")
}

func RegisterMsgServer(s grpc1.Server, srv MsgServer) {
	s.RegisterService(&_Msg_serviceDesc, srv)
}

func _Msg_RegisterCounterpartyAddress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgRegisterCounterpartyAddress)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).RegisterCounterpartyAddress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ibc.applications.fee.v1.Msg/RegisterCounterpartyAddress",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).RegisterCounterpartyAddress(ctx, req.(*MsgRegisterCounterpartyAddress))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_PayPacketFee_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgPayPacketFee)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).PayPacketFee(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ibc.applications.fee.v1.Msg/PayPacketFee",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).PayPacketFee(ctx, req.(*MsgPayPacketFee))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_PayPacketFeeAsync_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgPayPacketFeeAsync)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).PayPacketFeeAsync(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ibc.applications.fee.v1.Msg/PayPacketFeeAsync",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).PayPacketFeeAsync(ctx, req.(*MsgPayPacketFeeAsync))
	}
	return interceptor(ctx, in, info, handler)
}

var _Msg_serviceDesc = grpc.ServiceDesc{
	ServiceName: "ibc.applications.fee.v1.Msg",
	HandlerType: (*MsgServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RegisterCounterpartyAddress",
			Handler:    _Msg_RegisterCounterpartyAddress_Handler,
		},
		{
			MethodName: "PayPacketFee",
			Handler:    _Msg_PayPacketFee_Handler,
		},
		{
			MethodName: "PayPacketFeeAsync",
			Handler:    _Msg_PayPacketFeeAsync_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "ibc/applications/fee/v1/tx.proto",
}

func (m *MsgRegisterCounterpartyAddress) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRegisterCounterpartyAddress) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRegisterCounterpartyAddress) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CounterpartyAddress) > 0 {
		i -= len(m.CounterpartyAddress)
		copy(dAtA[i:], m.CounterpartyAddress)
		i = encodeVarintTx(dAtA, i, uint64(len(m.CounterpartyAddress)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgRegisterCounterpartyAddressResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRegisterCounterpartyAddressResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRegisterCounterpartyAddressResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgPayPacketFee) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgPayPacketFee) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgPayPacketFee) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Relayers) > 0 {
		for iNdEx := len(m.Relayers) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Relayers[iNdEx])
			copy(dAtA[i:], m.Relayers[iNdEx])
			i = encodeVarintTx(dAtA, i, uint64(len(m.Relayers[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.RefundAccount) > 0 {
		i -= len(m.RefundAccount)
		copy(dAtA[i:], m.RefundAccount)
		i = encodeVarintTx(dAtA, i, uint64(len(m.RefundAccount)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.SourceChannelId) > 0 {
		i -= len(m.SourceChannelId)
		copy(dAtA[i:], m.SourceChannelId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.SourceChannelId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SourcePortId) > 0 {
		i -= len(m.SourcePortId)
		copy(dAtA[i:], m.SourcePortId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.SourcePortId)))
		i--
		dAtA[i] = 0x12
	}
	if m.Fee != nil {
		{
			size, err := m.Fee.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgPayPacketFeeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgPayPacketFeeResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgPayPacketFeeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgPayPacketFeeAsync) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgPayPacketFeeAsync) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgPayPacketFeeAsync) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Relayers) > 0 {
		for iNdEx := len(m.Relayers) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Relayers[iNdEx])
			copy(dAtA[i:], m.Relayers[iNdEx])
			i = encodeVarintTx(dAtA, i, uint64(len(m.Relayers[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.RefundAccount) > 0 {
		i -= len(m.RefundAccount)
		copy(dAtA[i:], m.RefundAccount)
		i = encodeVarintTx(dAtA, i, uint64(len(m.RefundAccount)))
		i--
		dAtA[i] = 0x1a
	}
	if m.PacketId != nil {
		{
			size, err := m.PacketId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Fee != nil {
		{
			size, err := m.Fee.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgPayPacketFeeAsyncResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgPayPacketFeeAsyncResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgPayPacketFeeAsyncResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func encodeVarintTx(dAtA []byte, offset int, v uint64) int {
	offset -= sovTx(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *MsgRegisterCounterpartyAddress) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.CounterpartyAddress)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgRegisterCounterpartyAddressResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgPayPacketFee) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Fee != nil {
		l = m.Fee.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.SourcePortId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.SourceChannelId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.RefundAccount)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if len(m.Relayers) > 0 {
		for _, s := range m.Relayers {
			l = len(s)
			n += 1 + l + sovTx(uint64(l))
		}
	}
	return n
}

func (m *MsgPayPacketFeeResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgPayPacketFeeAsync) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Fee != nil {
		l = m.Fee.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	if m.PacketId != nil {
		l = m.PacketId.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.RefundAccount)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if len(m.Relayers) > 0 {
		for _, s := range m.Relayers {
			l = len(s)
			n += 1 + l + sovTx(uint64(l))
		}
	}
	return n
}

func (m *MsgPayPacketFeeAsyncResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func sovTx(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTx(x uint64) (n int) {
	return sovTx(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *MsgRegisterCounterpartyAddress) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRegisterCounterpartyAddress: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRegisterCounterpartyAddress: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CounterpartyAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CounterpartyAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRegisterCounterpartyAddressResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRegisterCounterpartyAddressResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRegisterCounterpartyAddressResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgPayPacketFee) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgPayPacketFee: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgPayPacketFee: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fee", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Fee == nil {
				m.Fee = &Fee{}
			}
			if err := m.Fee.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourcePortId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SourcePortId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceChannelId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SourceChannelId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefundAccount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RefundAccount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Relayers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Relayers = append(m.Relayers, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgPayPacketFeeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgPayPacketFeeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgPayPacketFeeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgPayPacketFeeAsync) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgPayPacketFeeAsync: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgPayPacketFeeAsync: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fee", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Fee == nil {
				m.Fee = &Fee{}
			}
			if err := m.Fee.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PacketId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PacketId == nil {
				m.PacketId = &types.PacketId{}
			}
			if err := m.PacketId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefundAccount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RefundAccount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Relayers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Relayers = append(m.Relayers, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgPayPacketFeeAsyncResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgPayPacketFeeAsyncResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgPayPacketFeeAsyncResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTx(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTx
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTx
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTx
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTx
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTx
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTx
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTx        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTx          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTx = fmt.Errorf("proto: unexpected end of group")
)
